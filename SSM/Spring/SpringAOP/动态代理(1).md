## 动态代理(1)----理论知识的深入理解

> 因为热爱，所以拼搏。      --RuiDer  2018-5-15
---------------------------

> 这段时间静下心摸索JavaEE中的Spring框架，于是遇到动态代理这个大坑，不过，怎么说呢，在这些难理解的知识点面前，还是静下心认真疏导一遍，
> 然后如果还存在问题或者不理解的问题，再疏导一遍，久而久之，你就会明白其中的原理，加油吧。。

### 前导必备

1. Java发射机制

2. 数据库事务的处理

3. Your Heart

### 理论理解

#### 一. 动态代理概念

` 动态代理的意义在于生成一个占位，又称代理对象，来代理真实的对象，从而控制真实对象的访问。Java中有多种动态代理的技术，比如JDK,CGLIB,
Javassist等，常用的就是JDK与CGLIB两种动态代理模式，下面我们主要说明JDK的代理模式。`

> 有人会问JDK与CGLIB的区别在哪，他们的区别在于被代理的对象是否需要实现接口或者说被代理的对象是否存在接口，如果存在接口，JDK动态代理可
以实现，如果没有实现任何接口，则推荐CGLIB动态代理模式。

#### 二. 动态代理原理浅析

所需资源：

1. 被代理对象类（Bean）

2. Bean的接口BeanInterface

3. 拦截器Intercepter,该拦截器实现程序执行流程的细节代码

4. 代理管理类ProxyUtil,实现java.lang.reflect.InvocationHandle接口，该接口定义一个invoke方法。该类负责生产代理对象,以及Proxy类的相关方法。

5. 反射机制的使用。

流程步骤：

1. 定义被代理对象以及拦截器Intercepter，包括拦截器的before,after等方法。

2. 通过向ProxyUtil的getBean方法传入参数，参数包括被代理对象（Bean），以及拦截器对象.getBean方法将获取代理对象的具体过程交给Proxy的
newProxyInstance方法获取代理对象。

3. 代理对象执行Bean方法时，会自动执行invoke方法。这里是真正的难点。

4. 至于invoke方法，无非就是按照事先约定好的流程去执行，首先执行拦截器中的before,之后执行bean内的方法，再执行拦截器的after方法，包括
自定义的afterRunning,afterThrowing方法，这里的afterRunning,afterThrowing是来源于SpringAOP中的动态代理模式方法。

> 需要掌握的地方包括整个动态代理的流程，理解拦截器的作用，推荐读者读读Proxy的源码，有助于读者更好地理解invoke方法的使用，以及原理的
深入理解。

